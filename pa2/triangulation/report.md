## 算法思路和实现要点

算法部分直接模拟题面描述的算法。

实现上，由于要频繁访问栈顶元素的下一个元素，而 `std::stack`  不支持随机访问，我使用 `std::vector` 的 `push_back` 和 `pop_back` 方法模拟栈。读取输入时，我记录了 $x$ 坐标最小和最大的点的位置，然后将所有点按照上半部分和下半部分两条单调链分类，存储在不同的 `std::vector` 内，分别维护一个指针，以按照 $x$ 坐标从小到大的顺序遍历所有点，实现题面描述的算法。每引入一条对角线，就即刻输出对应的三角形。

判断优劣点通过使用 to_left 测试判断该点两侧的点构成的向量与该点的位置关系来进行。每个点的坐标信息保存在结构体中，同时结构体内附有一个 `bool` 变量记录该点属于上单调链还是下单调链，以此确定 to_left 测试的结果。

## 渐进时间复杂度的分析

由于输入有序，因此无需排序，只需遍历所有点即可。在情况 2 中，每个点最多入栈一次，出栈一次。在情况 1 中，“原先的栈顶点”虽然出栈又入栈，但仅多出栈 1 次，相当于留在栈中，出入栈次数还是 $O(1)$ 量级。故算法的总时间复杂度为 $O(n)$。

## 渐进空间复杂度的分析

存储所有点，空间复杂度为 $O(n)$。