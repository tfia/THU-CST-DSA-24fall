## 算法思路和实现要点

使用并查集维护每个点所在的连通分量，当连接 $u, v$ 两点时，合并其所在的集合。再对每个连通分量维护一个大小固定为 $k$ 的小根堆，第 $k$ 大的点即为堆顶。当集合发生合并时，取出其中一个堆的所有元素插入另一个堆中，实现堆的合并。这里我还写了一个常数优化：当目标堆规模已经大于 $k$，则每次合并时将待合并元素先与目标堆堆顶元素进行比较，若待合并元素小于目标堆堆顶则直接跳过，避免把它插入之后还要弹出的情况出现。

开始时，由于尚未连边，每个点属于自己的连通分量，因此需要对每个点建立一个堆，为了不造成 MLE，必须使用类似 vector 的动态扩容过程。我采用了指针进行动态内存管理，在合并堆之后释放原有的空间来节约内存。

## 渐进时间复杂度的分析

每次合并堆时采取按秩合并，即把小的堆并入大的堆。这样，对于每一个点，其由于堆的合并而被移动的次数为 $O(\log n)$。大小为 $k$ 的堆插入删除的单次时间复杂度为 $O(\log k)$，点的总数为 $n$，因此堆合并的总时间复杂度为 $O(n\log n \log k)$。查询第 $k$ 大的点直接访问堆顶，时间复杂度 $O(1)$。

对于并查集，我使用了路径压缩，对于任意操作的时间复杂度为 $O(\alpha(n))$，其中 $n$ 为并查集森林的规模，$\alpha$ 为反阿克曼函数，可以基本上认为是 $O(1)$。连边操作最多有 $m + q$ 次，故总时间复杂度为 $O(m + q)$。

这样，解决本题的总时间复杂度为 $O(n\log n \log k + m + q)$。由于题目给出的 $n, m, k, q$ 取值范围均相同，因此也可以认为时间复杂度是 $O(n\log^2 n)$。由于常数优化，实际测试时常数很小。

## 渐进空间复杂度的分析

并查集和堆的空间复杂度都是 $O(n)$，故总空间复杂度为 $O(n)$。