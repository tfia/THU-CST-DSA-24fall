## 算法思路和实现要点

即为求点 $1$ 到点 $N$ 的最短路长度和数量。使用堆优化的 Dijkstra 算法求最短路，并在“松弛”过程中对最短路计数。

题目中给出的是点权，为了运行 Dijkstra 算法，将其转化为边权。具体地，对于 $u \rightarrow v$ 的边，令其边权为 $w(v)$。由于题目中给定的是无向边，故对 $(u, v)$，建立 $u \rightarrow v, w=w(v)$ 和  $v \rightarrow u, w=w(u)$ 两条边。

具体的计数操作在代码中有详细的注释。

## 渐进时间复杂度的分析

使用二叉堆维护 Dijkstra 需要的点集，有 $O(n)$ 次插入/删除操作、$O(m)$ 次“松弛”边的操作。每次有边被“松弛”，则要将其插入堆，故堆的规模为 $O(m)$，每次插入/删除堆的复杂度为 $O(\log m)$；每次“松弛”的复杂度为 $O(1)$。故总复杂度为 $O((n + m)\log m)$。

## 渐进空间复杂度的分析

使用邻接表存图，对于每个点，存储其所有出边，空间复杂度 $O(m)$。Dijkstra 的堆规模为 $O(m)$。总的空间复杂度为 $O(m)$。