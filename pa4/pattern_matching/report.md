## 算法思路和实现要点

考虑将字符串哈希扩展到二维。以下所有运算均在 $\bmod p$ 的意义下进行。

记一个 $n$ 行 $m$ 列的字符矩阵 $a$ 哈希值为
$$
\text{hash}(n, m) = \sum\limits_{i = 1}^n \sum\limits_{j = 1}^m \left( a_{i, j} \times b_1^{n - i} \times b_2^{m - j} \right)
$$

在我的实现中，我令 $b_1 = 19260817, b_2 = 13331$（均为质数），以使哈希尽量均匀。

由容斥原理，从 $(i_1, j_1)$ 到 $(i_2, j_2)$ 的子矩阵哈希为：
$$
H = \text{hash}(i_2, j_2) \\ - b_1^{i_2 - i_1 + 1}\text{hash}(i_1 - 1, j_2) \\ - b_2^{j_2 - j_1 + 1}\text{hash}(i_2, j_1 - 1) \\ + b_1^{i_2-i_1+1}b_2^{j_2-j_1+1}\text{hash}(i_1 - 1, j_1 - 1)
$$
只需预处理所有 $\text{hash}(i, j)$，即可在 $O(1)$ 时间内求任意子矩阵哈希。

题目限定了询问矩阵的大小为 $m \times n$，因此可以预处理出所有大小为 $m \times n$ 的子矩阵的哈希值。将这些哈希值排序，对于每个询问，先求出询问矩阵的哈希值，然后利用二分查找，在已经预处理过的哈希值中查询有多少个哈希值与询问矩阵相同，从而得出询问矩阵在大矩阵中出现的次数。

对于取模，我令 $p = 2^{64}$，在实现上利用 `unsigned long long` 类型的自然溢出来取模，避免了频繁的取模操作。

由于在预处理子矩阵时需要计算 $b$ 的幂，我预处理了 $b$ 的所有会用到的次幂来加速计算。

## 渐进时间复杂度的分析

预处理所有 $\text{hash}(i, j)$ 可以递推完成，复杂度 $O(MN)$。预处理所有大小为 $m \times n$ 的子矩阵哈希复杂度 $O(MN)$。排序的复杂度为 $O(MN\log(MN))$。对于单次询问，求询问矩阵哈希复杂度 $O(mn)$，在长度为 $M \times N$ 的序列上二分查找复杂度 $O(\log(MN))$。故总时间复杂度为 $O(MN + MN\log(MN) + k(mn + \log (MN))) = O(MN\log(MN) + k(mn + \log (MN)))$。由于 $m, n$ 相较 $M, n$ 十分小，若看作常数，可以认为时间复杂度是 $O((k+MN)\log(MN))$。

## 渐进空间复杂度的分析

需要储存 $M \times N$ 个子矩阵的哈希值，空间复杂度 $O(MN)$。