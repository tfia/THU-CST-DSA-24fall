`report.md` - 此文件，实验报告

`avl.cpp` - AVL 树实现

`splay.cpp` - Splay 实现

`std.cpp` - STL 实现，用于对拍

`gen.cpp` - 测例生成器

`gen.bat` - 自动调用测例生成器的脚本，运行可得到报告中描述的测例

`results.txt` - 测试的原始结果

`checker.cpp` - 自动评测器

`Makefile` - 用于快速编译上述程序

## 数据结构的实现过程及复杂度分析

考虑到运行时多态的性能开销，以及为了便于理解，我没有使用课件上继承虚基类的实现方式，而是利用全局数组模拟树，实现了 AVL 树和 Splay。

两种树在表示上是相似的。我定义如下全局数组：

``` cpp
int root, tot, fa[N], ch[N][2], val[N], h[N];
```

分别用于表示根节点的编号、节点总数、每个节点父节点的编号、每个节点左右儿子的编号、每个节点的权值，和以每个节点为根的子树的高度。

对于核心的旋转操作，我复用了相同的代码，区别只在更新 root 的时机不同。

``` cpp
bool get_which(int x) { return x == ch[fa[x]][1]; } // lc -> 0, rc -> 1
void rotate(int x) // x is lc -> right, x is rc -> left
{
    int f = fa[x], gf = fa[f];
    bool which = get_which(x);
    ch[f][which] = ch[x][which ^ 1]; // 将 x 的左子树挂到 f 的右子树，或对称
    if(ch[x][which ^ 1]) fa[ch[x][which ^ 1]] = f;
    ch[x][which ^ 1] = f;
    fa[f] = x;
    fa[x] = gf; // 更新父亲
    if(gf) ch[gf][f == ch[gf][1]] = x; // 更新祖父的儿子
    push_up(f);
    push_up(x); // 更新高度
    if(!fa[x]) root = x; // 需要更新根节点
} // 将 x 转到其父的位置
```

该旋转函数可以根据目标节点是左儿子还是右儿子，自动判断旋转方向，避免了单独编写左旋和右旋，使得代码更简单。

其余实现较为平凡，已在代码中使用注释说明，此处不再描述。

分析 Splay 的时间复杂度，利用势能分析。定义单个节点的势能为 $w(x) = \log(\text{size}(x))$。则每次操作的均摊成本为 $c = t + \Delta w$，$t$ 为实际操作的代价。

设 $w$ 代表旋转前势能，$w'$ 代表旋转后势能，$x$ 为旋转节点，$f$ 为其父亲，$g$ 为其祖父。

对 zig 操作，有
$$
c = 1 + w'(x) + w'(f) - w(x) - w(f)\\
= 1 + w'(f) - w(x)\\
\leq 1 + w'(x) - w(x)
$$
对 zig-zig 操作，有
$$
c = 2 + w'(x) + w'(f) + w'(g) - w(x) - w(f) - w(g)\\
 = 2 + w'(f) + w'(g) - w(x) - w(f)\\
 \leq 2w'(x) + w'(f) - 2w(x) - w(f)\\
 \leq 3(w'(x) - w(x))
$$
对 zig-zag 操作，有
$$
c = 2 + w'(x) + w'(f) + w'(g) - w(x) - w(f) - w(g)\\
 = 2 + w'(f) + w'(g) - w(x) - w(f)\\
 \leq 2w'(x) -w(x) - w(f)\\
 \leq 2(w'(x) - w(x))
$$
zag, zag-zag, zag-zig 与上述三种操作完全对称。

因此，每次操作至多花费 $3(w'(x) - w(x))$。假设极端情况下，$x$ 从叶子转到根，则 $3(w'(x) - w(x)) = 3\log n - 3 = O(\log n)$。从而，每次 splay 操作的均摊复杂度为 $O(\log n)$。Splay 插入删除查找过程都是先搜索再旋转，搜索即为二叉搜索树上的搜索，为 $O(\log n)$，旋转为 $O(\log n)$，故任意操作的均摊复杂度均为 $O(\log n)$。

AVL 树强制平衡，保证树高为 $O(\log n)$。加之调整平衡的过程中只需沿父亲向上，则单次调整的复杂度为 $O(\log n)$。故 AVL 树任意操作的复杂度均为 $O(\log n)$。

Splay 和 AVL 树的空间复杂度都是 $O(n)$。

## 设计测例的思路

由于 Splay 的树高并没有像 AVL 树一样严格的保证，而是依靠伸展操作每次把使用过的节点旋转到根部，因此连续访问同一节点（询问局部性好）只需要 $O(1)$ 的时间，最坏的询问复杂度（询问局部性差）可以达到 $O(n)$，因此为了对比 Splay 和 AVL 树，我分别构造了询问局部性好和询问局部性差的两组数据，再给出一组纯随机的数据作为参照。

数据组 1 包含 4 条测试数据，均为纯随机生成，A B C 三种操作的期望次数都为 $\frac{n}{3}$ 次，每次询问不保证询问的元素存在。4 条测试数据分别满足 $n = 10^3, n = 10^4, n = 10^5, n = 10^6$。

数据组 2 包含 4 条测试数据，保证只存在 A C 操作，且先进行一半的 A 操作，再进行一半的 C 操作，所有 C 操作具有良好的访问局部性。具体地，所有 A 操作插入的元素大小单增，所有 C 操作都查询插入的最大的元素（这样可以使得 AVL 树的每次查询都在叶子节点，差距更明显）。4 条测试数据分别满足 $n = 10^3, n = 10^4, n = 10^5, n = 10^6$。

数据组 3 包含 4 条测试数据，保证只存在 A C 操作，且先进行一半的 A 操作，再进行一半的 C 操作，所有 C 操作具有较差的访问局部性。具体地，所有 A 操作和 C 操作均随机，且每次询问不保证询问的元素存在。4 条测试数据分别满足 $n = 10^3, n = 10^4, n = 10^5, n = 10^6$。

## 测例如何生成

我的生成器位于 `gen.cpp`，运行 `gen.bat` 即可得到上述的所有测例。

在生成器内部，我使用 `std::uniform_int_distribution` 得到均匀分布的随机数，并使用 `std::set` 维护已经插入元素的集合，方便生成合法的 B 操作。

## 不同数据结构在不同测例下的性能描述及原因分析

我编写了评测器自动运行所有测例并与利用了 `std::set` 的实现对拍，保证实现的正确性。我的评测器位于 `checker.cpp`，测试结果原始文件位于 `results.txt`。

组 1（纯随机生成）

|       | $n=10^3$ | $n=10^4$ | $n=10^5$ | $n=10^6$ |
| ----- | -------- | -------- | -------- | -------- |
| Splay | 0.077s   | 0.083s   | 0.173s   | 1.144s   |
| AVL   | 0.077s   | 0.082s   | 0.166s   | 1.062s   |

组 2（询问局部性好）

|       | $n=10^3$ | $n=10^4$ | $n=10^5$ | $n=10^6$ |
| ----- | -------- | -------- | -------- | -------- |
| Splay | 0.073s   | 0.086s   | 0.16s    | 0.98s    |
| AVL   | 0.076s   | 0.081s   | 0.171s   | 1.107s   |

组 3（询问局部性差）

|       | $n=10^3$ | $n=10^4$ | $n=10^5$ | $n=10^6$ |
| ----- | -------- | -------- | -------- | -------- |
| Splay | 0.074s   | 0.085s   | 0.22s    | 1.898s   |
| AVL   | 0.075s   | 0.082s   | 0.187s   | 1.423s   |

由上述数据可以发现，$n$ 在 $10^4$ 或更小的量级时，两种树在所有数据上的表现均接近，在 $10^5$ 及以上时出现较明显的差距。

在随机数据集下，Splay 几乎总慢于 AVL。这可能是因为 Splay 的单次操作可能达到 $O(n)$，而这样的操作在随机数据中出现次数较多。此外，我的 Splay 实现的常数可能也大于 AVL。

在访问局部性好的数据集下，Splay 展现出一定的优势。这是由于每次查询相同节点，由于第一次每次查询都将查询的节点转到树根，因此 Splay 的复杂度是  $O(1)$，而 AVL 的复杂度是 $O(\log n)$。尽管编译器、处理器或操作系统对这种相同的查询可能做了一些缓存优化，提高了 AVL 的速度，但由于复杂度的本质区别，Splay 仍然更快。

在访问局部性差的数据集下，AVL 展现出较大的优势。由于局部性差，两种树都没有缓存优化的保证， 而 AVL 强制平衡，其时间复杂度为稳定的 $O(\log n)$，因此比复杂度并不稳定的 Splay 跑得更快。