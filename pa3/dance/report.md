## 算法思路和实现要点

使用无旋 Treap（FHQ Treap）维护舞者序列。容易发现所有操作与舞者代号 $x$ 无关，只与舞者位置 $i$ 有关，因此采用按子树大小分裂 Treap 的方式来维护。Treap 保证中序遍历等于原序列，则操作序列特定位置的元素，只需要分裂出子树大小等于该元素位置序数的子树。对于整体旋转操作，相当于分裂出左右两颗子树，然后反过来合并。对于区间反转操作，发现其等价于分裂出表示待翻转区间的子树，然后交换其所有子树的左右孩子。对于每个树上节点，维护一个 lazy tag 标记以其为根的子树代表的区间是否被翻转，在查询时再下推标记，从而优化翻转和查询的时间复杂度。最后打印所有节点时，dfs 输出整颗 Treap 的中序遍历结果即可。

具体的操作原理已经在代码中用详细的注释说明。

## 渐进时间复杂度的分析

所有操作都是一次或多次 FHQ Treap 按子树大小的分裂或合并。每次分裂或合并，寻找树根的过程相当于在有序的序列上查找一个特定元素，而涉及到下推 tag 时，只需要下推一层，下推的时间复杂度为 $O(1)$，故单次操作的时间复杂度为 $O(\log N)$。共有 $M$ 次操作，最后再输出所有节点，故总时间复杂度为 $O(M\log N + N)$。

## 渐进空间复杂度的分析

树上每个节点相当于序列中的一个元素，无需保存更多额外信息，故空间复杂度为 $O(N)$。