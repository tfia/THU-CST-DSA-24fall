## 算法思路和实现要点

使用 2D Tree 维护平面上所有坐标点。对于每个点，记录其对应的矩形范围内所有点温度的最大值和最小值。对于每次查询，从树根开始往下跳，将所有节点分为三类：查询矩形与子树矩形无交、查询矩形完全包含子树矩形、查询矩形部分包含子树矩形。先判断查询矩形是否与子树矩形无交、查询矩形是否完全包含子树矩形，若属于这两种情况之一则直接返回记录的最值（剪枝）；若不属于这两种情况，则递归查询左右子树对应的矩形。

实际测试时，发现这样的运行时间仍不能满足要求，因此对每次查询再记录一个全局最大值和一个全局最小值。若待查询子树对应矩形的最值不优于当前的全局最值，则不进入这个子树搜寻，起到剪枝的作用。

## 渐进时间复杂度的分析

建树时，每次选择当前维度坐标中位数的节点，然后递归建立左右子树。对于这种选择操作，使用 quickselect，依据课件上的证明，复杂度为 $O(n)$。因此，依据主定理，建树的复杂度为 $T(n) = 2T(\frac{n}{2}) + O(n) = O(n \log n)$。

依据课上的证明，2D Tree 上单次操作的时间复杂度为 $O(\sqrt n)$。$m$ 次操作，时间复杂度为 $O(m \sqrt n)$。

总的时间复杂度为 $O(n\log n + m\sqrt n)$。

## 渐进空间复杂度的分析

只需存储平面上所有点，与点的坐标无关，空间复杂度 $O(n)$。