## 算法思路和实现要点

对两个串使用动态规划算法求最长公共子序列（LCS）。LCS 之外的部分即为两个串“不一样”的部分，需要花费代价删除。记串 A 长度为 $n$，串 B 长度为 $m$，LCS 长度为 $l$，则答案为 $n + m - 2l$。

具体实现上，需要用滚动数组的技巧将 dp 数组压掉一维，否则会超出题目的空间限制。此外，直接求 LCS 时间复杂度为 $O(nm)$，无法通过最大数据，需要优化。在求 LCS 的时候，我们只考虑与 A 串长度相差在 $k$ 以内的情形（超过 $k$ 则无论如何在 $k$ 步内无法转化），这样将时间复杂度优化为 $O(nk)$，可以通过本题。

## 渐进时间复杂度的分析

如前文，dp 过程包含两重循环，外层范围为 $n$，内层为 $2k$。因此时间复杂度为 $O(nk)$。

## 渐进空间复杂度的分析

只需要开与串长相同的一维数组（实现上是二维数组，但第一维大小为常数 $2$）。空间复杂度为 $O(n)$。